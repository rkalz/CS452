\documentclass{article}

\title{CS 452: Assignment 2}
\date{September 15, 2018}
\author{Rofael Aleezada}

\usepackage[left=2.5cm, right=2.5cm, top=2.5cm]{geometry}
\usepackage{mathtools,graphicx,amsmath,xfrac,algpseudocode}

\begin{document}
    \maketitle
    
    \section{Question 1}
    What is the recurrence of the running time for the closest-pair problem using the:
    	\begin{itemize}
    		\item Brute force algorithm
    			\begin{itemize}
    				\item The brute force algorithm is composed of iterative for loops
    				\item Given an array of points of length n, the outer loop will iterate n times (over each point)
    				\item The inner loop will run n - i times, where i is the current value of the outer loop
    				\item The longest run of the inner loop will be when i is zero, so the inner loop runs n times
    				\item Therefore, the total run time of the brute force algorithm is $O(n*n)$, or $O(n^2)$
    			 \end{itemize}
    		\item Divide and conquer algorithm
    			\begin{itemize}
    				\item The divide and conquer algorithm works as follows:
    				\item First, sort the points by their x-coordinates (an $O(nlogn)$ operation)
    				\item Then, divide the array of points along the median, and find the closest pair for each half
    				\item Then, compare the distances of the two halves and select the smaller of the two 
    				\item Continue until the recursion is complete, giving you the smallest distance
    				\item The recursive dividing of the array can be written as $T(n) = 2T(n/2)$
    				\item And the comparisons of all the distance values will be $O(n)$    			
    				\item Thus, the recurrence of the divide and conquer algorithm is $T(n) = 2T(n/2) + O(n)$
    			\end{itemize}
    	\end{itemize}
    
    \pagebreak
    \section{Question 2}
    When performing merge sort on the array $[5, 3, 8, 9, 1, 7, 0, 2, 6, 4]$, and if you were to glue together the two subarrays
    prior to the final merge, what would be the value of the seventh number in that array?
    	\begin{itemize}
    		\item The following graph shows how merge sort would sort this array
    	\end{itemize}
    	\begin{center}
    		\includegraphics[scale=0.5]{q2.png}
    	\end{center}
    	\begin{itemize}
    		\item As shown, the two arrays prior to the final merge are $[1, 3, 5, 8, 9]$ and $[0, 2, 4, 6, 7]$
    		\item \textbf{Assuming that the 1st element is 1, the 7th element is 2.} 
    	\end{itemize}
    
   \pagebreak
   \section{Question 3}
   Use Karatsuba's method to compute $1201 * 2430$, exiting the recursion when $n = 1$, and compare to the traditional method.
   	\begin{itemize}
   		\item Karatsuba's method
   			\begin{itemize}
   				\item 
   					\begin{center}
   						\includegraphics[scale=0.5]{q3.png}
   					\end{center}
   				\item 12 operations are performed
   			\end{itemize}
   		\item Traditional method
   			\begin{itemize}
   				\item $1201 * 2430 = 1201 * 0 + 1201 * 30 + 1201 * 400 + 1201 * 2000$
   				\item $1201 * 0 = 1*0 + 0*0 + 2*0 + 1*0 = 0$ (4 operations)
   				\item $1201 * 30 = 10(1*3 + 0*3 + 2*3 + 1*3) = 36030$ (4 operations)
   				\item $1201 * 400 = 100(1*4 + 0*4 + 2*4 + 1*4) = 480400$ (4 operations)
   				\item $1201 * 2000 = 1000(1*2 + 0*2 + 2*2 + 1*2) = 2402000$ (4 operations)
   				\item $0 + 36030 + 480400 + 2402000 = 2918430$
   				\item 16 operations are performed
   			\end{itemize}
  	\end{itemize}
  
  \pagebreak
  \section{Question 4}
  Use Strassen's Algorithm (stop recursion when $n = 2$) to compute
  \[
  	\begin{bmatrix}
  		1 & 0 & 2 & 1 \\
  		4 & 1 & 1 & 0 \\
  		0 & 1 & 3 & 0 \\
  		5 & 0 & 2 & 1
  	\end{bmatrix}
  	X
  	\begin{bmatrix}
  	0 & 1 & 0 & 1 \\
  	2 & 1 & 0 & 4 \\
  	2 & 0 & 1 & 1 \\
  	1 & 3 & 5 & 0
  	\end{bmatrix}
  \]
\begin{itemize}
 	\item Strassen's Algorithm
 		\begin{itemize}
 			\item Divide both matrices each into four 2x2 matrices
 			\item 
 				\[
 					X = 
 					\begin{bmatrix}
 					1 & 0 & 2 & 1 \\
 					4 & 1 & 1 & 0 \\
 					0 & 1 & 3 & 0 \\
 					5 & 0 & 2 & 1
 					\end{bmatrix}
 					\rightarrow A = 
 					\begin{bmatrix}
 					1 & 0 \\
 					4 & 1
 					\end{bmatrix}
 					B = 
 					\begin{bmatrix}
 					2 & 1 \\
 					1 & 0
 					\end{bmatrix}
 					C = 
 					\begin{bmatrix}
 					0 & 1 \\
 					5 & 0
 					\end{bmatrix}
 					D = 
 					\begin{bmatrix}
 					3 & 0 \\
 					2 & 1
 					\end{bmatrix}
 				\]
		\item 
			\[
				Y = 
				\begin{bmatrix}
				0 & 1 & 0 & 1 \\
				2 & 1 & 0 & 4 \\
				2 & 0 & 1 & 1 \\
				1 & 3 & 5 & 0
				\end{bmatrix}
				\rightarrow E = 
				\begin{bmatrix}
				0 & 1 \\
				2 & 1
				\end{bmatrix}
				F = 
				\begin{bmatrix}
				0 & 1 \\
				0 & 4
				\end{bmatrix}
				G = 
				\begin{bmatrix}
				2 & 0 \\
				1 & 3
				\end{bmatrix}
				H = 
				\begin{bmatrix}
				1 & 1 \\
				5 & 0
				\end{bmatrix}
			\]
		\item Per Strasson's Algorithm, the following computations are performed
			\begin{itemize}
				\item $M_1 = (A + C) * (E + F)$
					\begin{itemize}
						\item 
							\[
								A + C = 
								\begin{bmatrix}
								1 + 0 & 0 + 1 \\
								4 + 5 & 1 + 0
								\end{bmatrix}
								= 
								\begin{bmatrix}
								1 & 1 \\
								9 & 1
								\end{bmatrix}
							\]
						\item
							\[
							E + F = 
							\begin{bmatrix}
							0 + 0 & 1 + 1 \\
							2 + 0 & 1 + 4
							\end{bmatrix}
							= 
							\begin{bmatrix}
							0 & 2 \\
							2 & 5
							\end{bmatrix}
							\]
						\item
							\[
								(A + C) * (E + F) = 
								\begin{bmatrix}
								2 & 7 \\
								2 & 23
								\end{bmatrix}
							\]
					\end{itemize}
				\item $M_2 = (B + D) * (G + H)$
					\begin{itemize}
						\item 
						\[
						B + D = 
						\begin{bmatrix}
						2 + 3 & 1 + 0 \\
						1 + 2 & 0 + 1
						\end{bmatrix}
						= 
						\begin{bmatrix}
						5 & 1 \\
						3 & 1
						\end{bmatrix}
						\]
						\item
						\[
						G + H = 
						\begin{bmatrix}
						2 + 1 & 0 + 1 \\
						1 + 5 & 3 + 0
						\end{bmatrix}
						= 
						\begin{bmatrix}
						3 & 1 \\
						6 & 3
						\end{bmatrix}
						\]
						\item
						\[
						(B + D) * (G + H) = 
						\begin{bmatrix}
						21 & 8 \\
						15 & 6
						\end{bmatrix}
						\]
					\end{itemize}
				\pagebreak
				\item $M_3 = (A - D) * (E + H)$
					\begin{itemize}
						\item 
						\[
						A - D = 
						\begin{bmatrix}
						1 - 3 & 0 - 0 \\
						4 - 2 & 1 - 1
						\end{bmatrix}
						= 
						\begin{bmatrix}
						-2 & 0 \\
						2 & 0
						\end{bmatrix}
						\]
						\item
						\[
						E + H = 
						\begin{bmatrix}
						0 + 1 & 1 + 1 \\
						2 + 5 & 1 + 0
						\end{bmatrix}
						= 
						\begin{bmatrix}
						1 & 2 \\
						7 & 1
						\end{bmatrix}
						\]
						\item
						\[
						(A - D) * (E + H) = 
						\begin{bmatrix}
						-2 & -4 \\
						2 & 4
						\end{bmatrix}
						\]
					\end{itemize}
				\item $M_4 = A * (F - H)$
					\begin{itemize}
						\item 
						\[
						F - H = 
						\begin{bmatrix}
						0 - 1 & 1 - 1 \\
						2 - 5 & 1 - 0
						\end{bmatrix}
						= 
						\begin{bmatrix}
						-1 & 0 \\
						-3 & 1
						\end{bmatrix}
						\]
						\item
						\[
						A * (F - H) = 
						\begin{bmatrix}
						-1 & -0 \\
						-7 & 1
						\end{bmatrix}
						\]
					\end{itemize}
				\item $M_5 = (C + D) * E$
					\begin{itemize}
						\item 
						\[
						C + D = 
						\begin{bmatrix}
						0 + 3 & 1 + 0 \\
						5 + 2 & 0 + 1
						\end{bmatrix}
						= 
						\begin{bmatrix}
						3 & 1 \\
						7 & 1
						\end{bmatrix}
						\]
						\item
						\[
						(C + D) * E = 
						\begin{bmatrix}
						2 & 4 \\
						2 & 8
						\end{bmatrix}
						\]
					\end{itemize}
				\item $M_6 = (A + B) * H$
					\begin{itemize}
						\item 
						\[
						A + B = 
						\begin{bmatrix}
						1 + 2 & 0 + 1 \\
						4 + 1 & 1 + 0
						\end{bmatrix}
						= 
						\begin{bmatrix}
						3 & 1 \\
						5 & 1
						\end{bmatrix}
						\]
						\item
						\[
						(A + B) * H = 
						\begin{bmatrix}
						8 & 3 \\
						10 & 5
						\end{bmatrix}
						\]
					\end{itemize}
				\item $M_7 = D * (G - E)$ 
					\begin{itemize}
						\item 
						\[
						G - E = 
						\begin{bmatrix}
						2 - 0 & 0 - 1 \\
						1 - 2 & 3 - 1
						\end{bmatrix}
						= 
						\begin{bmatrix}
						2 & -1 \\
						-1 & 2
						\end{bmatrix}
						\]
						\item
						\[
						D * (G - E) = 
						\begin{bmatrix}
						6 & -3 \\
						3 & 0
						\end{bmatrix}
						\]
					\end{itemize}
			\end{itemize}
		\item The final solution is as follows
			\[
			Z = 
			\begin{bmatrix}
			I & J \\
			K & L \\
			\end{bmatrix}
			=
			\begin{bmatrix}
			M_2 + M_3 - M_6 - M_7 && M_4 + M_6 \\
			M_5 + M_7 && M_1 - M_3 - M_4 - M_5
			\end{bmatrix}
			=
			\begin{bmatrix}
			5 & 4 & 7 & 3 \\
			4 & 5 & 1 & 9 \\
			8 & 1 & 3 & 7 \\
			5 & 8 & 7 & 7
			\end{bmatrix}
			\]
 		\end{itemize}
	\end{itemize}

	\pagebreak
	\section{Question 5}
	What are the minimum and maximum possible recursion depths for a randomized Quicksort?
		\begin{itemize}
			\item The minimum possible recursion depth, which occurs when the median is picked, is $O(log(n))$
			\item The maximum possible recursion depth, which occurs when the smallest number is picked, is $O(n)$
		\end{itemize}
	\section{Question 6}
	Convert the following recurrence formula into Big O notation: 
	$T(1) = 1$ and $T(n) \le T(\sqrt n)+1$ 
		\begin{itemize}
			\item $T(n) = T(n/2) + 1$ is $O(\log n)$ because the resulting tree has a height of $\log_2 n$
			\item For this recurrence, we are dividing $n$ by a factor of two, this the Big O form will be $O(\log \log n)$
		\end{itemize}
	\section{Question 7}
	Given an array of unique values that starts in ascending order, reaches a max value, then goes into descending order,
	find the max value in logarithmic time
		\begin{algorithmic}
			\Function{findMax}{arr, a, b}
				\Comment{Searches for the maximum value in arr in range $[a, b]$}
				\If{a == b}
					\Return arr[a]
				\EndIf
				\If{b - a == 1}
					\Return \Call{max}{arr[a], arr[b]}
				\EndIf
					\Comment{Assume the median is the largest value}
				
				m = arr[(a + b) / 2]
				
				mLeft = \Call{findMax}{arr, a, m - 1}
				
				mRight = \Call{findMax}{arr, m + 1, b}
					\Comment{Compare with the other medians}
				\If{m $\ge$ mLeft \textbf{and} m $\ge$ mRight}
					\Return m
				\EndIf
				\If{mLeft $\ge$ m \textbf{and} mLeft $\ge$ mRight}
					\Return mLeft
				\EndIf
				
				\Return mRight
			\EndFunction
		\end{algorithmic}
	\section{Question 8}
	Given a sorted array containing unique positive, negative, and zero integers, determine where there exists a value $i$ such that $A[i] = i$ 
	as time efficient as possible
		\begin{algorithmic}
			\Function{findIEqualsAI}{arr}
			
				max = \Call{len}{arr} 
				
				zeroPos = \Call{binarySearch}{arr, 0, max - 1}
				
				\For{i in [zeroPos, max]}
					\If{arr[i] == i}
						\Return true
					\EndIf
				\EndFor
		
				\Return false
			\EndFunction
			
		\end{algorithmic}
	
	\pagebreak
	\section{Question 9}
	Given an array with a random k shift, find a value in logarithmic time
		\begin{algorithmic}
			\Function{findInKShifted}{arr, val, a, b}
				\If{a == b and arr[a] != val} 
					\Return -1 
				\EndIf
				
				m = $(a + b) / 2$
				\If{arr[m] == val} 
					\Return m 
				\EndIf
				
				\If{arr[m-1] $\le$ arr[m] $\le$ arr[m+1]}
					\Comment{If median is in correct order, we can search like normal Binary Search}
					\If{val $>$ arr[m]} 
						\Return \Call{findInKShifted}{arr, val, m + 1, b} 
					\Else 
						\Return \Call{findInKShifted}{arr, val, a, m-1} 
					\EndIf
				\Else
					\Comment{Otherwise, have to flip because value is on other side}
					\If{val $>$ arr[m]} 
						\Return \Call{findInKShifted}{arr, val, a, m-1} 
					\Else 
						\Return \Call{findInKShifted}{arr, val, m+1, b} 
					\EndIf
				\EndIf
			\EndFunction
		\end{algorithmic}
	\section{Question 10}
	Design a recursive algorithm for solving $2^n = 2^{(n-1)}  + 2^{(n-1)}$. Set up a recurrence relation for the number of additions and draw a tree of recursive calls
		\begin{algorithmic}
			\Function{twoToThePower}{n}
				\If{n == 0}
					\Return 1
				\EndIf
				
				\Return \Call{twoToThePower}{n-1} + \Call{twoToThePower}{n-1}
			\EndFunction
		\end{algorithmic}
	
	The recurrence relationship would be $T(0) = 1$ and $T(n) = 2T(n-1)$
		\begin{itemize}
			\item $T(n) = 2T(n-1)$
			\item $T(n-1) = 2*2T(n-2) = 4*T(n-2)$
			\item $T(n-2) = 4*2T(n-3) = 8*T(n-2)$
			\item $T(n) = 2^n * 1 = 2^n$
		\end{itemize}
	The recurrence relationship will have $2^n$ additions.
	\begin{center}
		\includegraphics[scale=0.1]{q10.jpg}
	\end{center}
	\section{Question 11}
	Consider the provided algorithm. If it is correct, prove it. Otherwise, fix it. 
	\begin{itemize}
		\item The algorithm will fail because it is not actually accumulating if a leaf is traversed
	\end{itemize}
	A corrected form would be
		\begin{algorithmic}
			\Function{LeafCounter}{T}
				\If{T is empty} 
					\Return 0
				\EndIf
				
				\If{$T_{left}$ is empty and $T_{right}$ is empty}
					\Return 1
				\EndIf
				
				\Return \Call{LeafCounter}{$T_{left}$} + \Call{LeafCounter}{$T_{right}$}
			\EndFunction
		\end{algorithmic}
	\section{Question 12}
	Design an algorithm that rearranges an array such that all negative numbers precede all positive numbers in efficient space and time complexity
		\begin{algorithmic}
			\Function{rearrange}{arr}
				
				positives = []
				
				negatives = []
				
				\For{num in arr}
					\If{num $<$ 0}
						\Call{append}{negatives, num}
					\Else
						\Call{append}{positives, num}
					\EndIf
				\EndFor
				
				\For{pos in positives}
					\Call{append}{negatives, pos}
				\EndFor
				
				\Return negatives
			\EndFunction
		\end{algorithmic}
	Linear space and linear time complexity
  
\end{document}